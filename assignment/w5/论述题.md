# 题目 01- 请你说一说什么是线程和进程？
## 区别
进程是计算机内存中正在执行的程序，而线程是进程中的执行单元。其区别是进程拥有独立的内存空间。而同进程中的线程可以共享堆空间与方法区。
## 关系
一个进程中 可以有多个线程。一个线程总是隶属于某个进程。
## 线程的上下文切换是什么？
线程的上下文切换是指CPU为了在一定时间段内支持多个线程的执行。会给每一个线程分配一个大概几十毫秒的执行时间，这叫做时间片。在线程A用完了它的时间片，
需要切换到线程B时，CPU会记录一下线程A的执行状态（包括运行到哪个指令，相关变量的值等）。等到下次再执行线程A时，CPU就会读取上次保存的线程A的状态。
这个存储当前状态和再读取之前状态的过程就叫做线程的上下文切换。
## 线程的并发与并行有何区别？
并发是指在一段时间内，多个线程同时执行，但是可能存在一个单位时间内（即有某个时刻）各线程是串行执行的。
并行是在任意单位时间内（即任意时刻），都有多个线程同时执行。

# 题目 02- 使用了多线程会带来什么问题呢？
多线程会带来线程安全问题。它是指多个线程所读取到的状态总和和合理的整体状态不一致，从而导致一些不合理的结果。导致线程安全问题的原因都是因为全局或
静态变量共享。
## 原子性
指一个线程的某个操作对外部线程而言只能感受到两种状态，要么已完成，要么未执行。不会让外部线程感受到其他中间结果。
## 可见性
指一个线程修改了某个共享变量后，修改后的值可以及时被其他线程看到。
## 有序性
多线程对共享变量的读写为了能有合理的解释而需要遵循的一种顺序。这种顺序需要得到指令重排序和编译重排序的配合才行。

# 题目 03- 什么是死锁？如何排查死锁?

# 题目 04- 请你说一说 synchronized 和 volatile 的原理与区别
synchronized本质上是锁，所以在synchronized内部任意时刻最多只有一个线程在执行。而volatile只是遵循了jmm
的规定，所有线程在读volatile变量时，统一从主内存加载。在写volatile变量时，马上写入主内存。synchronized
的原理是利用锁的升级和管程来尽可能用最小代价实现对锁的支持。因而，synchronized既能保证原子性，又能保证可见性。
而volatile则是通过禁止volatile变量操作前后的指令重排序和编译重排序来保证JMM要求的读写顺序。可以保证可见性，
但不能保持原子性。但volatile实现方案简单，性能优于synchronized.

## 什么是 JMM内存模型？
JMM内存模型是JVM工程师为了简化Java工程师在做并发编程时的难度，而对硬件开发商和Java编译器提出的规范。只要他们遵循这套规范，就不会出现不可解释的
并发问题。
## 什么是 happens-before 规则？
JMM为了保证多线程共享变量的可见性而提出的一系列具体的规则。最重要的是以下四点：
1. 程序顺序规则：单线程中的每个操作都应该在任意后续操作之前发生。
2. 锁规则：任意锁的解锁都发生在对这个锁的加锁之前。
3. volatile变量规则：对一个volatile变量的写发生在对这个变量后续的读之前。
4. 传递性：如果A happens-before B, B happens-before C, 则A happens-before C.