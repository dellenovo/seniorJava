# 题目 01- 请你说一说 MySQL 的锁机制
按照锁的粒度来分，最大的是全局锁。它由sql layer发起。当加了数据库锁后，整个数据库都不能进行写操作。通常被用在数据库迁移的场景下。  
其次是表锁，是指意向锁，也由sql layer。即表示表中有记录的写锁，为了提高其他session判断表中是否有写锁的效率，可以直接判断该表是否有意向锁。
再者是由存储引擎如InnoDB发起的锁，上锁的对象是索引的记录、记录之间的间隙及记录和间隙的组合，分别对应记录锁和插入意向锁、间隙锁、临键锁。  
按锁的功能分，分为写锁和读锁。写锁又叫独占锁、排他锁，加了写锁的记录不允许其他事务再在这条记录上加锁。读锁也叫共享锁，一个记录上可以叠加读锁，  
但会阻塞写锁。
记录锁是粒度最小的锁，通常在RC、RR隔离级别下，可以使用聚簇和唯一性索引的场景下的等值匹配会被触发。
间隙锁锁的是记录之间的间隙。当隔离级别为RC、RR时，使用索引做范围查询时会被触发。
临键锁是索引记录和比它小的间隙构成。
如果写sql时没有注意到加锁的顺序，就可能会造成死锁。死锁是指占有锁的事务又在等待被其他事务占用的锁释放，而这个等待关系形成一个环时，就是死锁。
当我们分析该sql delete from tt where uid = 666 的锁定情况时，需要按照数据库的隔离级别和索引匹配分情况讨论。
当隔离级别是RU时，不加锁。  
当隔离级别是RC或RR，并且用到了主键或唯一性索引时，如果等值匹配到记录，那加的是记录写锁。 如果匹配不到，那加的是间隙锁。 
当隔离级别是RC或RR，并且用到了主键或唯一性索引时，如果等值无匹配，加的是间隙锁；如果等值匹配到记录，那加的是临键锁。
当隔离级别是RC或RR，并且也没有用到索引时，innoDB会给全表每一条记录都加写锁，但是不符合过滤条件的记录的锁会被sql server释放。
当隔离级别是Serialize时，通过悲观锁的方式执行该sql, 用的并不是MVCC中使用的锁。

# 题目 02- 请你说一说 MySQL 的 SQL 优化
可以用explain来分析sql的执行计划。按照执行计划暴露的问题，调整sql，尽量用到该表的索引，尽量避免全表扫描。少用子查询，尽量用join代替。   
join时尽量小表驱动大表。where条件中尽量不要用not in，建议使用not exists.