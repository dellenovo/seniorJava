# 题目 01: 请你用自己的语言介绍 Java 运行时数据区（内存区域）
1. 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存  
**答：**  

堆：存放Java程序中的对象，所有的线程都共享堆。  

虚拟机栈：是一个存放线程中的Java代码执行到哪一步的栈。因此每个线程有它自己的虚拟机栈。也就是说，虚拟机栈不是多线程共享的。这个栈里的每个
元素是一个结构体，叫做栈帧。栈帧中包含着当前执行到的指令、本地变量、方法和入参等。每进入一个方法调用，就会把新的对应的栈帧入栈；
每退出一个方法调用，就会把一个栈顶的栈帧出栈。  

本地方法栈：类似虚拟机栈，不同点是保存的是线程中native方法执行到哪一步。因此，当线程还没有执行到native方法，本地方法栈是空的。只有当进入
native方法后，本地方法栈才会有值。  
  
方法区：一块保存非对象的内存空间，比如可以保存字符串常量池、类信息等。方法区在jdk 1.8以前叫永久代，在jdk 1.8及以后叫方法区。类信息存在
元空间。  
  
运行时常量池：Java Application在运行时需要的常量存放的地方。其中字符串集中存放在运行时常量池中的字符串常量池。  
  
直接内存：JVM为了高效存取物理机内存，而绕过了JVM内存。这个被JVM直接分配和访问的物理内存空间就是直接内存。

2. 为什么堆内存要分年轻代和老年代？  

**答：** 基于弱分代假说，大部分的对象的生命周期非常短；基于强分代假说，如果对象能够在前期存活下来，那么也意味着它很有可能在未来能继续存活。
所以，由此就会把对象分为两类，一类短命，另一类长寿。并且短命的占大多数。在对象中大多数都是需要被回收的，少数是不回收的。大多数需要被回收的，
占用内存空间一般较大；而少数长寿的占用空间不大。这些相对性质决定了需要用不同的策略来对这两种对象做垃圾回收，所以要区分年轻代和老年代。  

# 题目 02：描述一个 Java 对象的生命周期
* 解释一个对象的创建过程
* 解释一个对象的内存分配
* 解释一个对象的销毁过程
* 对象的 2 种访问方式是什么？
* 为什么需要内存担保？
   
**答：** 
* 对象的创建  
程序通过显式（比如new）或者隐式（由框架来完成，比如Spring framework的IoC）的方式通知JVM需要创建属于某种类型的对象。在创建过程中如果发现类还没有
被加载到JVM中，JVM首先会去寻找对应该类的.class文件来加载该类到JVM内存的方法区中的元数据区。加载类完毕后，JVM便会根据元数据区中
该类的信息得知需要的内存空间大小，然后在Heap中的Eden判断是否能够容纳得下。如果容纳得下，就会在Eden区创建该对象，并做初始化和实例化。如果容纳
不下，就会继续在Survivor寻找空间，如果还是容纳不小，则寻找Tenure，如果还是不行，则抛出OOM。哪里发现容纳的下，就在哪里创建该对象。
* 对象的内存分配
分配给对象的内存中，一开始是对象头，里面包含MARK WORD、类型指针。接下来是存放类成员的区域。最后是补齐区域。目的是把一个对象占用的内存大小补齐
到32Byte的整数倍。
* 对象的销毁  
当JVM通过根可达算法无法标记到某个对象时，该对象基本上就成为随时会"死"之"人"，随时随刻都会被垃圾回收器销毁。垃圾回收器通过各种算法（标记-整理、
标记-复制，标记-清除）回收已经不可能被访问到的对象所占据的内存空间。
* 对象的2种访问方式  
？  
* 为什么需要内存担保？  
由于JVM heap被划分为了Eden, Survivor, Tenure， 为了尽可能地容纳下更多的对象。不可能仅仅尝试某一个堆内存区域，而是要穷尽所有类型的内存区域。
所以自然会有内存担保，并且内存担保的顺序依次就是Eden, Survivor, Tenure。  

# 题目 03 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？
* ParNew 收集器
* ParallelScavenge 收集器
* ParallelOld 收集器
* CMS 收集器
* G1 收集器  
**答：** 垃圾收集算法分为标记-清除（mark-sweep）、标记-整理（mark-compact）和标记-复制（mark-copy）。他们都是采用可达性分析来找出仍然在被
引用的对象，关键区别是处理不再被引用的对象（也就是垃圾）的方式上。请看下表： 

| 垃圾收集算法 | 主要内容                   | 优点             | 缺点         |适用场景|
|-----------|------------------------|----------------|------------|------|
| 标记-清除  | 只清除垃圾，回收垃圾所在的内存空间      | 速度快            | 容易产生内存碎片   |垃圾不太多|
| 标记-整理  | 清除垃圾后，把活着的对象都移向内存地址的一侧 | 解决了内存碎片问题      | 移动对象需付出额外时间 |垃圾不太多|
| 标记-复制  | 只把活着的对象复制到另一块等大的内存区域   | 无内存碎片问题，移动逻辑简单 | 空间利用率低|垃圾较多|

垃圾收集器和它们的特点请见下表：

| 垃圾收集算法           | 特点                                                                                                                       |
|------------------|--------------------------------------------------------------------------------------------------------------------------|
| ParNew           | 并行执行标记-整理算法                                                                                                              |
| ParallelScavenge | 并行执行标记-复制算法                                                                                                              |
| ParallelOld      | ？                                                                                                                        |
| CMS              | 并行标记-清除                                                                                                                  |
| G1               | 将整个JVM heap分为一个个region, 每个region属于不同的类型（Eden, Survivor, Tenure & Homogous).<br/>全局使用标记-清除,但每个region可按照region的类型自定义垃圾收集算法 |